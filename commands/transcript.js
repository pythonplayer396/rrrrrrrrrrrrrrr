const {
  SlashCommandBuilder,
  PermissionFlagsBits,
  AttachmentBuilder,
  ChannelType,
} = require("discord.js");
const fs = require("fs");
const path = require("path");
const { closeReason } = require("./close");
require("dotenv").config();
const ticketSetup = require("../schema/ticketSchema");
const channelData = require("../schema/ticketDetail");

module.exports = {
  data: new SlashCommandBuilder()
    .setName("transcript")
    .setDescription("Generate and save the ticket transcript.")
    .setDefaultMemberPermissions(PermissionFlagsBits.ManageMessages),

  run: async ({ interaction }) => {
    const member = await interaction.guild.members.fetch(interaction.user.id);

    await interaction.deferReply({ flags: 1 << 6 });

    const channel = interaction.channel;
    const channelId = channel.id;
    const channelEntry = channelData.findOne({ channelId });

    // âœ… Check if it's a ticket channel
    if (!channelEntry) {
      return interaction.editReply({
        content: "âŒ This is not a valid ticket channel.",
        flags: 1 << 6,
      });
    }
    const guildId = interaction.guild.id;
    const entry = await ticketSetup.findOne({ guildId });
    // âœ… Role check (staff role ID)
    const hasPermission = member.roles.cache.has(entry.highStaffRole) || 
                         member.roles.cache.has(entry.slayerCarrierRoleId) || 
                         member.roles.cache.has(entry.dungeonCarrierRoleId);
    if (!hasPermission) {
      return interaction.editReply({
        content: "âŒ You don't have permission to use this command.",
        flags: 1 << 6,
      });
    }

    try {
      const messages = await fetchMessages(channel);

      if (!messages.length) {
        return interaction.editReply({
          content: "âŒ No messages found in this channel.",
          flags: 1 << 6,
        });
      }

      // âœ… Format the transcript
      const transcript = messages
        .reverse() // From oldest to newest
        .map(
          (m) =>
            `${new Date(m.createdTimestamp).toLocaleString()} | ${m.author.tag
            }: ${m.content || "[Embed/Attachment]"}`
        )
        .join("\n");

      // âœ… Define file path
      const fileName = `transcript-${channel.name}.txt`;
      const filePath = path.join(__dirname, "..", "transcripts", fileName);

      // âœ… Ensure transcripts directory exists
      fs.mkdirSync(path.dirname(filePath), { recursive: true });

      // âœ… Write transcript to file
      fs.writeFileSync(filePath, transcript);

      // âœ… Create attachment
      const attachment = new AttachmentBuilder(filePath);

      // âœ… Reply in the current channel
      await interaction.editReply({
        content: `ðŸ“‘ Transcript has been generated.`,
        files: [attachment],
        flags: 1 << 6,
      });

      // âœ… Optionally send to staff logs channel
      const logsChannelId = process.env.transcriptChannelId;
      let logsChannel;

      try {
        logsChannel = await interaction.guild.channels.fetch(logsChannelId);
      } catch (fetchErr) {
        console.error("Failed to fetch logs channel:", fetchErr);
      }

      if (logsChannel && logsChannel.type === ChannelType.GuildText) {
        await logsChannel.send({
          content: `ðŸ“‘ Transcript for **${channel.name}** generated by <@${interaction.user.id}> \nClose Reason: ${closeReason}`,
          files: [attachment],
          flags: 1 << 6,
        });
      }

      // âœ… Clean up file after sending
      fs.unlinkSync(filePath);
    } catch (error) {
      console.error("Transcript Error:", error);
      await interaction.editReply({
        content: "âŒ An error occurred while generating the transcript.",
        flags: 1 << 6,
      });
    }
  },
};

async function fetchMessages(channel) {
  let messages = [];
  let lastId;

  while (true) {
    const options = { limit: 100 };
    if (lastId) options.before = lastId;

    const fetched = await channel.messages.fetch(options);

    if (fetched.size === 0) break;

    messages.push(...fetched.map((msg) => msg));
    lastId = fetched.last().id;
  }

  return messages;
}
